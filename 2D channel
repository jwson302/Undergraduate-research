import deepxde as dde
import numpy as np
from tensorflow.keras.backend import set_floatx
from deepxde.backend import tf

set_floatx("float64")

#parameters(SI units)
H = 0.025
rho = 1500
eta_0 = 60
eta_inf = 0.01
lamb = 0.8
n = 0.5
f = 4
L = 0.5
T = 10
u_max = 1.02
m_A = 0.1

#characteristic scales
char_x = L
char_y = H
char_t = 1 # 1 or 1/(2*np.pi*f) or L/u_max
char_u = u_max
char_v = (H/L)*u_max
char_p = rho*(u_max**2) # (eta_0*L*u_max)/(H**2) or (eta_0*u_max)/L or rho*(u_max**2)


geom = dde.geometry.Rectangle([0, -H/char_y], [L/char_x, H/char_y])
timedomain = dde.geometry.TimeDomain(0, T/char_t)
geomtime = dde.geometry.GeometryXTime(geom, timedomain)


def pde(x, u):
    # x = [x, y, t]
    # u = [u_vel(or v_x), v_vel(or v_y), p]
    u_vel, v_vel, p = u[:, 0:1], u[:, 1:2], u[:, 2:]
    
    u_vel_x = dde.grad.jacobian(u, x, i=0, j=0)
    u_vel_y = dde.grad.jacobian(u, x, i=0, j=1)
    u_vel_t = dde.grad.jacobian(u, x, i=0, j=2)
    u_vel_xx = dde.grad.hessian(u, x, component=0, i=0, j=0)
    u_vel_yy = dde.grad.hessian(u, x, component=0, i=1, j=1)
    u_vel_xy = dde.grad.hessian(u, x, component=0, i=0, j=1)
    
    v_vel_x = dde.grad.jacobian(u, x, i=1, j=0)
    v_vel_y = dde.grad.jacobian(u, x, i=1, j=1)
    v_vel_t = dde.grad.jacobian(u, x, i=1, j=2)
    v_vel_xx = dde.grad.hessian(u, x, component=1, i=0, j=0)
    v_vel_yy = dde.grad.hessian(u, x, component=1, i=1, j=1)
    v_vel_xy = dde.grad.hessian(u, x, component=1, i=0, j=1)
    
    p_x = dde.grad.jacobian(u, x, i=2, j=0)
    p_y = dde.grad.jacobian(u, x, i=2, j=1)
    
    shear_sqrd = ((u_vel_y*(char_u/char_y) + v_vel_x*(char_v/char_x))**2 +
                        2*((u_vel_x*(char_u/char_x))**2) + 2*((v_vel_y*(char_v/char_y))**2))
    eta = eta_inf + (eta_0 - eta_inf)*(1+(lamb**2)*shear_sqrd)**((n-1)/2)

    eta_x = dde.grad.jacobian(eta, x, i=0, j=0)
    eta_y = dde.grad.jacobian(eta, x, i=0, j=1)
    
    momentum_x = (
       u_vel_t*(char_u/char_t) + u_vel*u_vel_x*((char_u**2)/char_x) + v_vel*u_vel_y*(char_u*char_v/char_y) 
       - (1/rho)*(-p_x*(char_p/char_x) + 2*eta_x*u_vel_x*(char_u/(char_x**2)) 
                  + 2*eta*u_vel_xx*(char_u/(char_x**2))
                 + eta_y*u_vel_y*(char_u/(char_y**2)) + eta_y*v_vel_x*(char_v/(char_x*char_y))
                 + eta*u_vel_yy*(char_u/(char_y**2)) + eta*v_vel_xy*(char_v/(char_x*char_y)))
    )
    momentum_y = (
        v_vel_t*(char_v/char_t) + u_vel*v_vel_x*(char_u*char_v/char_x) + v_vel*v_vel_y*((char_v**2)/char_y) 
       - (1/rho)*(-p_y*(char_p/char_y) + 2*eta_y*v_vel_y*(char_v/(char_y**2))
                  + 2*eta*v_vel_yy*(char_v/(char_y**2))
                 + eta_x*u_vel_y*(char_u/(char_x*char_y)) + eta_x*v_vel_x*(char_v/(char_x**2))
                 + eta*v_vel_xx*(char_v/(char_x**2)) + eta*u_vel_xy*(char_u/(char_x*char_y)))
    )
    continuity = u_vel_x*(char_u/char_x) + v_vel_y*(char_v/char_y)

    return [momentum_x, momentum_y, continuity]

def top_boundary(x, on_boundary):
    return on_boundary and np.isclose(x[1], H/char_y)
def bottom_boundary(x, on_boundary):
    return on_boundary and np.isclose(x[1], -H/char_y)
def left_boundary(x, on_boundary):
    return on_boundary and np.isclose(x[0], 0)
def right_boundary(x, on_boundary):
    return on_boundary and np.isclose(x[0], L/char_x)

def input_vel(x):
    return ((u_max/char_u)*(1+(x[:, 1:2]*char_y/H))*(1-(x[:, 1:2]*char_y/H))
            *(1+(m_A*np.sin(2*np.pi*f*char_t*x[:, 2:3]))))

bc_top_u_vel = dde.icbc.DirichletBC(
    geomtime, lambda x: 0, top_boundary, component=0)
bc_bottom_u_vel = dde.icbc.DirichletBC(
    geomtime, lambda x: 0, bottom_boundary, component=0)
bc_left_u_vel = dde.icbc.DirichletBC(
    geomtime, input_vel, left_boundary, component=0)

bc_top_v_vel = dde.icbc.DirichletBC(
    geomtime, lambda x: 0, top_boundary, component=1)
bc_bottom_v_vel = dde.icbc.DirichletBC(
    geomtime, lambda x: 0, bottom_boundary, component=1)
bc_left_v_vel = dde.icbc.DirichletBC(
    geomtime, lambda x: 0, left_boundary, component=1)

bc_right_p = dde.icbc.DirichletBC(
    geomtime, lambda x: 0, right_boundary, component=2)


data = dde.data.TimePDE(
    geomtime, pde, [bc_top_u_vel, bc_bottom_u_vel, bc_left_u_vel, bc_top_v_vel,
                   bc_bottom_v_vel, bc_left_v_vel, bc_right_p],
    num_domain=5000, num_boundary=3000)

net = dde.nn.FNN([3] + [50] * 6 + [3], "tanh", "Glorot normal")
model = dde.Model(data, net)

model.compile("adam", lr=1e-3, loss_weights=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
model.train(iterations=99000)
model.compile("L-BFGS", loss_weights=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1])
losshistory, train_state = model.train()
dde.saveplot(losshistory, train_state, issave=True, isplot=True)


